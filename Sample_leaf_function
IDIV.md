C.1. Sample leaf function
IDIV // x y
RET
We have used a total of 27 operations and 28 bytes, the same as the previous
version (with the ROT optimization). However, we did not use the commuta-
tivityofmultiplicationhere,sowecansaythatcompoundstackmanipulation
primitives enable us to reduce the code size from 29 to 28 bytes.
Yet again, notice that the above code might have been generated by an
unsophisticated compiler. Manual optimizations might lead to more com-
pact code; for instance, we could use compound operations such as XCHG3
to prepare in advance not only the correct values of s0 and s1 for the next
arithmetic operation, but also the value of s2 for the arithmetic operation
after that. The next section provides an example of such an optimization.
C.1.7. Stack machine with compound stack primitives and manu-
ally optimized code. The previous version of code for a stack machine
with compound stack primitives can be manually optimized as follows.
By interchanging XCHG operations with preceding XCHG, PUSH, and arith-
metic operations whenever possible, we obtain code fragment XCHG s2,s6;
XCHG s1,s0; XCHG s0,s5, which can then be replaced by compound oper-
ation XCHG3 s6,s0,s5. This compound operation would admit a two-byte
encoding, thus leading to 27-byte code using only 21 operations:
PUSH2 s5,s2 // a b c d e f a d
IMUL // a b c d e f ad
PUSH2 s5,s4 // a b c d e f ad b c
IMUL // a b c d e f ad bc
SUB // a b c d e f ad-bc
PUXC s2,s3 // a b c ad-bc e f e d
IMUL // a b c D e f ed
XCHG3 s6,s0,s5 // (same as XCHG s2,s6; XCHG s1,s0; XCHG s0,s5)
// e f c D a ed b
PUSH s5 // e f c D a ed b f
IMUL // e f c D a ed bf
SUB // e f c D a ed-bf
XCHG s4 // e Dx c D a f
IMUL // e Dx c D af
XCHG2 s4,s2 // D Dx af e c
IMUL // D Dx af ec
153

