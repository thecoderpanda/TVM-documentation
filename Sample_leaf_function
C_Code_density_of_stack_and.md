C.1. Sample leaf function
C Code density of stack and register machines
This appendix extends the general consideration of stack manipulation prim-
itives provided in 2.2, explaining the choice of such primitives for TVM, with
a comparison of stack machines and register machines in terms of the quan-
tity of primitives used and the code density. We do this by comparing the
machine code that might be generated by an optimizing compiler for the
same source files, for different (abstract) stack and register machines.
It turns out that the stack machines (at least those equipped with the ba-
sic stack manipulation primitives described in 2.2.1) have far superior code
density. Furthermore, the stack machines have excellent extendability with
respect to additional arithmetic and arbitrary data processing operations, es-
pecially if one considers machine code automatically generated by optimizing
compilers.
C.1 Sample leaf function
We start with a comparison of machine code generated by an (imaginary)
optimizing compiler for several abstract register and stack machines, cor-
responding to the same high-level language source code that contains the
definition of a leaf function (i.e., a function that does not call any other func-
tions). For both the register machines and stack machines, we observe the
notation and conventions introduced in 2.1.
C.1.1. Sample source file for a leaf function. Thesourcefileweconsider
contains one function f that takes six (integer) arguments, a, b, c, d, e, f,
and returns two (integer) values, x and y, which are the solutions of the
system of two linear equations
(cid:40)
ax+by = e
(6)
cx+dy = f
The source code of the function, in a programming language similar to C,
might look as follows:
(int, int) f(int a, int b, int c, int d, int e, int f) {
int D = a*d - b*c;
int Dx = e*d - b*f;
int Dy = a*f - e*c;
147

